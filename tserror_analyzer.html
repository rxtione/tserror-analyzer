<!DOCTYPE html>
<html lang="ko">
<head>
    <!-- Ezoic Privacy Scripts (ë°˜ë“œì‹œ ë¨¼ì € ë¡œë“œ) -->
    <script data-cfasync="false" src="https://cmp.gatekeeperconsent.com/min.js"></script>
    <script data-cfasync="false" src="https://the.gatekeeperconsent.com/cmp.min.js"></script>

    <!-- Ezoic Header Script -->
    <script async src="//www.ezojs.com/ezoic/sa.min.js"></script>
    <script>
        window.ezstandalone = window.ezstandalone || {};
        ezstandalone.cmd = ezstandalone.cmd || [];
    </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TypeScript ì˜¤ë¥˜ ë¶„ì„ê¸°</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Malgun Gothic', 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        h1 { color: white; text-align: center; margin-bottom: 10px; font-size: 28px; }
        .subtitle { color: #b8d4ff; text-align: center; margin-bottom: 20px; font-size: 13px; }
        .panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e8f0fe;
        }
        .panel-title { font-size: 15px; font-weight: 600; color: #1a73e8; }
        textarea {
            width: 100%;
            height: 180px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px;
            font-family: 'Consolas', monospace;
            font-size: 11px;
            resize: vertical;
        }
        textarea:focus { outline: none; border-color: #1a73e8; }
        .btn-group { display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap; }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            font-family: 'Malgun Gothic', sans-serif;
        }
        .btn-primary { background: linear-gradient(135deg, #1a73e8, #1557b0); color: white; }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(26,115,232,0.4); }
        .btn-secondary { background: #f1f3f4; color: #5f6368; }
        .result-section { display: none; }
        .result-section.active { display: block; }

        /* í•µì‹¬ ìš”ì•½ ë°•ìŠ¤ */
        .summary-box {
            background: #fff3e0;
            border: 2px solid #ff9800;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .summary-title { font-size: 16px; font-weight: bold; color: #e65100; margin-bottom: 15px; }

        /* ë¬¸ì œ ì¹´ë“œ */
        .problem-card {
            background: #ffebee;
            border-left: 4px solid #f44336;
            border-radius: 0 8px 8px 0;
            padding: 15px;
            margin-bottom: 12px;
        }
        .problem-number {
            display: inline-block;
            background: #f44336;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            text-align: center;
            line-height: 24px;
            font-size: 12px;
            font-weight: bold;
            margin-right: 10px;
        }
        .problem-title { font-weight: 600; color: #c62828; display: inline; }
        .problem-path {
            margin-top: 10px;
            padding: 8px 12px;
            background: #fff;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            color: #7b1fa2;
        }
        .problem-detail {
            margin-top: 15px;
        }
        .type-comparison {
            display: grid;
            grid-template-columns: 1fr 40px 1fr;
            gap: 10px;
            align-items: stretch;
        }
        .type-column {
            min-width: 0;
        }
        .type-arrow-center {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #9e9e9e;
        }
        .type-box {
            padding: 12px;
            border-radius: 6px;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            word-break: break-all;
            white-space: pre-wrap;
            line-height: 1.6;
        }
        .type-box.wrong {
            background: #fff5f5;
            border: 2px solid #ef9a9a;
            color: #333;
        }
        .type-box.correct {
            background: #f5fff5;
            border: 2px solid #a5d6a7;
            color: #333;
        }
        /* í‹€ë¦° ë¶€ë¶„ ê°•ì¡° */
        .type-box .error-highlight {
            background: #ff5252;
            color: white;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
        }
        .type-box .correct-highlight {
            background: #4caf50;
            color: white;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
        }
        .type-arrow {
            font-size: 20px;
            color: #9e9e9e;
        }
        .type-label {
            font-size: 10px;
            color: #757575;
            margin-bottom: 3px;
        }

        /* í•´ê²° ë°©ë²• */
        .solution-box {
            background: #e8f5e9;
            border: 2px solid #4caf50;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        .solution-title { font-weight: 600; color: #2e7d32; margin-bottom: 10px; }
        .solution-code {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 12px;
            border-radius: 6px;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            overflow-x: auto;
            margin-top: 8px;
        }
        .solution-code .keyword { color: #569cd6; }
        .solution-code .string { color: #ce9178; }
        .solution-code .comment { color: #6a9955; }

        /* ì „ì²´ ì˜¤ë¥˜ ê²½ë¡œ (ì ‘ê¸°) */
        .error-trace {
            margin-top: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
        }
        .error-trace-header {
            background: #f5f5f5;
            padding: 12px 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            color: #616161;
        }
        .error-trace-header:hover { background: #eeeeee; }
        .error-trace-content {
            display: none;
            padding: 15px;
            background: #fafafa;
            max-height: 300px;
            overflow-y: auto;
        }
        .error-trace-content.open { display: block; }
        .trace-line {
            font-family: 'Consolas', monospace;
            font-size: 11px;
            padding: 4px 0;
            border-bottom: 1px solid #eee;
        }
        .trace-line:last-child { border-bottom: none; }
        .trace-indent { color: #bdbdbd; }

        .copy-btn {
            padding: 4px 10px;
            font-size: 11px;
            background: #e3f2fd;
            color: #1565c0;
            border-radius: 4px;
        }

        /* ë°°ì—´/ê°ì²´ ë¬¸ì œ ê°•ì¡° */
        .array-warning {
            background: #fff8e1;
            border: 2px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .array-warning-icon { font-size: 24px; margin-right: 10px; }
        .array-warning-text { color: #f57f17; font-weight: 600; }
    </style>
</head>
<body>
    <div class="container">
        <h1>TypeScript ì˜¤ë¥˜ ë¶„ì„ê¸°</h1>
        <p class="subtitle">ë³µì¡í•œ íƒ€ì… ì˜¤ë¥˜ë¥¼ ë¶„ì„í•˜ì—¬ ì–´ë–¤ í•„ë“œê°€ ë¬¸ì œì¸ì§€ ëª…í™•í•˜ê²Œ ì•Œë ¤ë“œë¦½ë‹ˆë‹¤</p>

        <div class="panel">
            <div class="panel-header">
                <span class="panel-title">TypeScript ì˜¤ë¥˜ ë©”ì‹œì§€ ì…ë ¥</span>
            </div>
            <textarea id="errorInput" placeholder="TypeScript ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”..."></textarea>
            <div class="btn-group">
                <button class="btn-primary" onclick="analyzeError()">ì˜¤ë¥˜ ë¶„ì„</button>
                <button class="btn-secondary" onclick="clearAll()">ì´ˆê¸°í™”</button>
                <button class="btn-secondary" onclick="loadSample()">ì˜ˆì‹œ ë¶ˆëŸ¬ì˜¤ê¸°</button>
            </div>
        </div>

        <div id="resultSection" class="result-section panel">
            <div class="panel-header">
                <span class="panel-title">ë¶„ì„ ê²°ê³¼</span>
                <button class="copy-btn" onclick="copyResult()">ë³µì‚¬</button>
            </div>
            <div id="resultContent"></div>
        </div>
    </div>

    <script>
        function analyzeError() {
            const input = document.getElementById('errorInput').value.trim();
            if (!input) {
                alert('ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!');
                return;
            }
            const result = parseTypeScriptError(input);
            displayResult(result);
        }

        function parseTypeScriptError(errorText) {
            const result = {
                problems: [],
                isArrayObjectMismatch: false,
                originalError: errorText
            };

            // ë°°ì—´/ê°ì²´ ë¶ˆì¼ì¹˜ ê°ì§€
            if (errorText.includes('length, pop, push, concat')) {
                result.isArrayObjectMismatch = true;
            }

            // ì˜¤ë¥˜ ê²½ë¡œ íŒŒì‹± - ì¤‘ì²©ëœ ì†ì„± ì¶”ì 
            const lines = errorText.split('\n');
            let currentPath = [];
            let problems = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();

                // ì†ì„± í˜¸í™˜ì„± ë¬¸ì œ ê°ì§€
                const propMatch = trimmed.match(/Types of property ['"]([^'"]+)['"] are incompatible/);
                if (propMatch) {
                    currentPath.push(propMatch[1]);
                }

                // íƒ€ì… í• ë‹¹ ë¶ˆê°€ ê°ì§€
                const typeMatch = trimmed.match(/Type ['"]([^'"]+)['"] is not assignable to type ['"]([^'"]+)['"]/);
                if (typeMatch) {
                    const sourceType = typeMatch[1];
                    const targetType = typeMatch[2];

                    // ì¤‘ê°„ ë‹¨ê³„ íƒ€ì… ë¹„êµì—ì„œ ê°œë³„ ì†ì„±ì˜ ë°°ì—´ ë¶ˆì¼ì¹˜ ì°¾ê¸°
                    const arrayMismatches = findArrayMismatchesInTypes(sourceType, targetType);

                    if (arrayMismatches.length > 0) {
                        // ê°œë³„ ì†ì„±ë³„ë¡œ ë¬¸ì œ ì¶”ê°€
                        arrayMismatches.forEach(mismatch => {
                            problems.push({
                                path: [...currentPath, mismatch.propName],
                                sourceType: mismatch.sourceType,
                                targetType: mismatch.targetType,
                                isArrayMismatch: true
                            });
                        });
                    } else {
                        problems.push({
                            path: [...currentPath],
                            sourceType: sourceType,
                            targetType: targetType,
                            isArrayMismatch: targetType.includes('[]') && !sourceType.includes('[]')
                        });
                    }
                }

                // ëˆ„ë½ëœ ì†ì„± ê°ì§€
                const missingMatch = trimmed.match(/is missing the following properties[^:]*: ([^.]+)/);
                if (missingMatch) {
                    const props = missingMatch[1].split(',').map(p => p.trim());
                    problems.push({
                        path: [...currentPath],
                        type: 'missing',
                        missingProps: props
                    });
                }
            }

            // ì¤‘ë³µ ì œê±° (ê°™ì€ ê²½ë¡œì˜ ë¬¸ì œ)
            result.problems = deduplicateProblems(problems);
            return result;
        }

        // ë‘ íƒ€ì… ë¬¸ìì—´ì—ì„œ ë°°ì—´ ë¶ˆì¼ì¹˜ ì†ì„± ì°¾ê¸°
        function findArrayMismatchesInTypes(sourceType, targetType) {
            const mismatches = [];

            // ê°ì²´ íƒ€ì…ì¸ ê²½ìš°ë§Œ ì²˜ë¦¬
            if (!sourceType.startsWith('{') || !targetType.startsWith('{')) {
                return mismatches;
            }

            // ì†ì„± ì¶”ì¶œ (ê°„ë‹¨í•œ íŒŒì‹±)
            const sourceProps = parseObjectProps(sourceType);
            const targetProps = parseObjectProps(targetType);

            // ê° ì†ì„± ë¹„êµ
            for (const propName of Object.keys(sourceProps)) {
                if (targetProps[propName]) {
                    const srcType = sourceProps[propName];
                    const tgtType = targetProps[propName];

                    // ë°°ì—´ ë¶ˆì¼ì¹˜ ì²´í¬: ëŒ€ìƒì€ []ë¥¼ í¬í•¨í•˜ê³  ì†ŒìŠ¤ëŠ” í¬í•¨í•˜ì§€ ì•ŠìŒ
                    const targetIsArray = tgtType.includes('[]');
                    const sourceIsArray = srcType.includes('[]');

                    if (targetIsArray && !sourceIsArray) {
                        mismatches.push({
                            propName: propName,
                            sourceType: srcType,
                            targetType: tgtType
                        });
                    }
                }
            }

            return mismatches;
        }

        // ê°ì²´ íƒ€ì… ë¬¸ìì—´ì—ì„œ ì†ì„± ì¶”ì¶œ
        function parseObjectProps(typeStr) {
            const props = {};
            // { prop1: type1; prop2?: type2; ... } í˜•íƒœ íŒŒì‹±

            // ë°”ê¹¥ìª½ ì¤‘ê´„í˜¸ ì œê±°
            let inner = typeStr.trim();
            if (inner.startsWith('{')) inner = inner.slice(1);
            if (inner.endsWith('}')) inner = inner.slice(0, -1);

            // ì†ì„± ë¶„ë¦¬ (ì¤‘ì²© ê°ì²´ ê³ ë ¤)
            let depth = 0;
            let current = '';
            let propName = '';
            let inPropName = true;

            for (let i = 0; i < inner.length; i++) {
                const char = inner[i];

                if (char === '{' || char === '[' || char === '(') depth++;
                else if (char === '}' || char === ']' || char === ')') depth--;

                if (depth === 0 && char === ':' && inPropName) {
                    propName = current.trim().replace('?', '');
                    current = '';
                    inPropName = false;
                } else if (depth === 0 && char === ';') {
                    if (propName) {
                        props[propName] = current.trim();
                    }
                    current = '';
                    propName = '';
                    inPropName = true;
                } else {
                    current += char;
                }
            }

            // ë§ˆì§€ë§‰ ì†ì„± ì²˜ë¦¬
            if (propName && current.trim()) {
                props[propName] = current.trim();
            }

            return props;
        }

        // ì¤‘ë³µ ë¬¸ì œ ì œê±°
        function deduplicateProblems(problems) {
            const seen = new Set();
            return problems.filter(p => {
                const key = p.path.join('.') + '|' + (p.type || 'type');
                if (seen.has(key)) return false;
                seen.add(key);
                return true;
            });
        }

        // íƒ€ì…ì„ ë³´ê¸° ì¢‹ê²Œ í¬ë§·íŒ… (ë“¤ì—¬ì“°ê¸° ì ìš©)
        function formatType(type) {
            let result = '';
            let depth = 0;

            for (let i = 0; i < type.length; i++) {
                const char = type[i];
                const nextChar = type[i + 1];

                if (char === '{') {
                    depth++;
                    result += '{\n' + '  '.repeat(depth);
                } else if (char === '}') {
                    depth--;
                    result += '\n' + '  '.repeat(depth) + '}';
                } else if (char === ';' && depth > 0) {
                    result += ';\n' + '  '.repeat(depth);
                } else if (char === '[' && nextChar === ']') {
                    result += '[]';
                    i++; // skip ]
                } else if (char === ' ' && result.endsWith('\n' + '  '.repeat(depth))) {
                    // skip leading space after newline
                    continue;
                } else {
                    result += char;
                }
            }

            // ì •ë¦¬
            return result
                .replace(/\n\s*\n/g, '\n')
                .replace(/\{\s+\}/g, '{}')
                .replace(/\[\s+\]/g, '[]')
                .trim();
        }

        // ë‘ íƒ€ì…ì„ ë¹„êµí•´ì„œ ë‹¤ë¥¸ ë¶€ë¶„ì„ ê°•ì¡° í‘œì‹œ
        function highlightTypeDiff(sourceType, targetType, isSource) {
            const type = isSource ? sourceType : targetType;
            const otherType = isSource ? targetType : sourceType;

            // í¬ë§·íŒ…ëœ íƒ€ì…
            const formatted = formatType(type);

            // ì†ì„±ë³„ë¡œ íŒŒì‹±
            const sourceProps = parseObjectProps(sourceType);
            const targetProps = parseObjectProps(targetType);

            // ë°°ì—´ ë¶ˆì¼ì¹˜ ì†ì„± ì°¾ê¸°
            const arrayMismatchProps = [];
            for (const propName of Object.keys(targetProps)) {
                const srcType = sourceProps[propName] || '';
                const tgtType = targetProps[propName] || '';

                if (tgtType.includes('[]') && !srcType.includes('[]')) {
                    arrayMismatchProps.push(propName);
                }
            }

            // HTMLë¡œ ë³€í™˜í•˜ë©´ì„œ ê°•ì¡°
            let html = escapeHtml(formatted);

            if (isSource) {
                // ì†ŒìŠ¤ì—ì„œ: ë°°ì—´ì´ì–´ì•¼ í•˜ëŠ” ì†ì„±ì˜ ê°’ ë¶€ë¶„ì„ ë¹¨ê°›ê²Œ
                arrayMismatchProps.forEach(propName => {
                    // propName: { ... } íŒ¨í„´ ì°¾ì•„ì„œ ê°•ì¡°
                    const regex = new RegExp(`(${escapeRegex(propName)}\\??:\\s*)([^;\\n]+)`, 'g');
                    html = html.replace(regex, (match, prefix, value) => {
                        if (!value.includes('[]')) {
                            return `${prefix}<span class="error-highlight">${value}</span>`;
                        }
                        return match;
                    });
                });

                // ì „ì²´ê°€ ë°°ì—´ì´ì–´ì•¼ í•˜ëŠ” ê²½ìš°
                if (targetType.endsWith('[]') && !sourceType.endsWith('[]')) {
                    html = `<span class="error-highlight">${html}</span>`;
                }
            } else {
                // íƒ€ê²Ÿì—ì„œ: [] ë¶€ë¶„ì„ ì´ˆë¡ìƒ‰ìœ¼ë¡œ ê°•ì¡°
                html = html.replace(/\[\]/g, '<span class="correct-highlight">[]</span>');
            }

            return html;
        }

        function escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function getTypeSummary(type) {
            if (type.includes('[]')) return 'ë°°ì—´ (Array)';
            if (type.startsWith('{')) return 'ê°ì²´ (Object)';
            if (type === 'string') return 'ë¬¸ìì—´';
            if (type === 'number') return 'ìˆ«ì';
            if (type === 'boolean') return 'ë¶ˆë¦¬ì–¸';
            if (type === 'undefined') return 'undefined';
            if (type === 'null') return 'null';
            return type;
        }

        function displayResult(result) {
            let html = '';

            // ë°°ì—´/ê°ì²´ ë¶ˆì¼ì¹˜ ê²½ê³ 
            if (result.isArrayObjectMismatch) {
                html += `
                    <div class="array-warning">
                        <span class="array-warning-icon">âš ï¸</span>
                        <span class="array-warning-text">ê°ì²´(Object)ë¥¼ ë°°ì—´(Array)ì´ í•„ìš”í•œ ê³³ì— ì „ë‹¬í–ˆìŠµë‹ˆë‹¤!</span>
                    </div>
                `;
            }

            // ìš”ì•½
            html += `<div class="summary-box">`;
            html += `<div class="summary-title">ğŸ” ë°œê²¬ëœ ë¬¸ì œ: ${result.problems.length}ê°œ</div>`;

            // ê° ë¬¸ì œ ì¹´ë“œ
            result.problems.forEach((problem, idx) => {
                html += `<div class="problem-card">`;
                html += `<span class="problem-number">${idx + 1}</span>`;

                if (problem.type === 'missing') {
                    html += `<span class="problem-title">ëˆ„ë½ëœ ì†ì„±</span>`;
                    if (problem.path.length > 0) {
                        html += `<div class="problem-path">ğŸ“ ìœ„ì¹˜: ${problem.path.join(' â†’ ')}</div>`;
                    }
                    html += `<div class="problem-detail">`;
                    html += `<div class="type-box wrong">í•„ìš”í•œ ì†ì„±: ${problem.missingProps.join(', ')}</div>`;
                    html += `</div>`;
                } else {
                    // ë°°ì—´ vs ê°ì²´ ë¬¸ì œ
                    if (problem.isArrayMismatch || (result.isArrayObjectMismatch && problem.path.length > 0)) {
                        html += `<span class="problem-title">ë°°ì—´/ê°ì²´ íƒ€ì… ë¶ˆì¼ì¹˜</span>`;
                    } else {
                        html += `<span class="problem-title">íƒ€ì… ë¶ˆì¼ì¹˜</span>`;
                    }

                    if (problem.path.length > 0) {
                        html += `<div class="problem-path">ğŸ“ ìœ„ì¹˜: ${problem.path.join(' â†’ ')}</div>`;
                    }

                    html += `<div class="problem-detail">`;
                    html += `<div class="type-comparison">`;

                    // ì „ë‹¬í•œ íƒ€ì… (ì™¼ìª½)
                    html += `<div class="type-column">`;
                    html += `<div class="type-label">âŒ ì „ë‹¬í•œ íƒ€ì… <span style="color:#b71c1c;">(${getTypeSummary(problem.sourceType)})</span></div>`;
                    html += `<div class="type-box wrong">${highlightTypeDiff(problem.sourceType, problem.targetType, true)}</div>`;
                    html += `</div>`;

                    // í™”ì‚´í‘œ (ì¤‘ì•™)
                    html += `<div class="type-arrow-center">â†’</div>`;

                    // ê¸°ëŒ€í•˜ëŠ” íƒ€ì… (ì˜¤ë¥¸ìª½)
                    html += `<div class="type-column">`;
                    html += `<div class="type-label">âœ… ê¸°ëŒ€í•˜ëŠ” íƒ€ì… <span style="color:#1b5e20;">(${getTypeSummary(problem.targetType)})</span></div>`;
                    html += `<div class="type-box correct">${highlightTypeDiff(problem.sourceType, problem.targetType, false)}</div>`;
                    html += `</div>`;

                    html += `</div>`; // type-comparison
                    html += `</div>`; // problem-detail
                }

                html += `</div>`;
            });

            html += `</div>`; // summary-box ë‹«ê¸°

            // í•´ê²° ë°©ë²•
            const arrayProblems = result.problems.filter(p => p.isArrayMismatch);
            if (result.isArrayObjectMismatch || arrayProblems.length > 0) {
                const propNames = arrayProblems.map(p => p.path[p.path.length - 1]).filter(Boolean);
                const uniquePropNames = [...new Set(propNames)];

                if (uniquePropNames.length === 0) {
                    uniquePropNames.push('data');
                }

                html += `
                    <div class="solution-box">
                        <div class="solution-title">ğŸ’¡ í•´ê²° ë°©ë²•</div>
                        <p style="margin-bottom:10px;color:#2e7d32;">ë‹¤ìŒ ì†ì„±ë“¤ì„ ë°°ì—´ë¡œ ê°ì‹¸ì£¼ì„¸ìš”:</p>
                        <div class="solution-code">
<span class="comment">// âŒ ì˜ëª»ëœ ì½”ë“œ</span>
${uniquePropNames.map(name => `${name}: { <span class="keyword">...</span> }`).join('\n')}

<span class="comment">// âœ… ì˜¬ë°”ë¥¸ ì½”ë“œ</span>
${uniquePropNames.map(name => `${name}: [{ <span class="keyword">...</span> }]`).join('\n')}
                        </div>
                    </div>
                `;
            }

            // ì „ì²´ ì˜¤ë¥˜ (ì ‘ê¸°)
            html += `
                <div class="error-trace">
                    <div class="error-trace-header" onclick="toggleTrace()">
                        <span>ğŸ“œ ì „ì²´ ì˜¤ë¥˜ ë©”ì‹œì§€ ë³´ê¸°</span>
                        <span id="traceArrow">â–¼</span>
                    </div>
                    <div class="error-trace-content" id="traceContent">
            `;

            const lines = result.originalError.split('\n');
            lines.forEach(line => {
                const indent = line.match(/^(\s*)/)[1].length;
                const indentStr = '<span class="trace-indent">' + 'â”‚ '.repeat(Math.floor(indent/2)) + '</span>';
                html += `<div class="trace-line">${indentStr}${escapeHtml(line.trim())}</div>`;
            });

            html += `</div></div>`;

            document.getElementById('resultContent').innerHTML = html;
            document.getElementById('resultSection').className = 'result-section panel active';
        }

        function toggleTrace() {
            const content = document.getElementById('traceContent');
            const arrow = document.getElementById('traceArrow');
            if (content.classList.contains('open')) {
                content.classList.remove('open');
                arrow.textContent = 'â–¼';
            } else {
                content.classList.add('open');
                arrow.textContent = 'â–²';
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function clearAll() {
            document.getElementById('errorInput').value = '';
            document.getElementById('resultSection').className = 'result-section panel';
        }

        function loadSample() {
            const sample = `Argument of type '{ generalInfo: { dsaleOutfirmName: string; bzpersonRegNo: string; }; bondProcure: { dsaleOutfirmNo: string; }[]; factoryEdit?: { deleteRequest: { dsaleOutfirmNo: string; }; insertRequest?: { dsaleOutfirmNo: string; } | undefined; } | undefined; }' is not assignable to parameter of type '{ generalInfo?: { dsaleOutfirmName: string; } | undefined; bondProcure?: { dsaleOutfirmNo: string; }[] | undefined; factoryEdit?: { insertRequest?: { dsaleOutfirmNo: string; }[] | undefined; deleteRequest?: { dsaleOutfirmNo: string; }[] | undefined; } | undefined; }'.
  Types of property 'factoryEdit' are incompatible.
    Type '{ deleteRequest: { dsaleOutfirmNo: string; }; insertRequest?: { dsaleOutfirmNo: string; } | undefined; }' is not assignable to type '{ insertRequest?: { dsaleOutfirmNo: string; }[] | undefined; deleteRequest?: { dsaleOutfirmNo: string; }[] | undefined; }'.
      Types of property 'insertRequest' are incompatible.
        Type '{ dsaleOutfirmNo: string; } | undefined' is not assignable to type '{ dsaleOutfirmNo: string; }[] | undefined'.
          Type '{ dsaleOutfirmNo: string; }' is not assignable to type '{ dsaleOutfirmNo: string; }[]'.
            Type '{ dsaleOutfirmNo: string; }' is missing the following properties from type '{ dsaleOutfirmNo: string; }[]': length, pop, push, concat, and 35 more.`;
            document.getElementById('errorInput').value = sample;
        }

        function copyResult() {
            const el = document.getElementById('resultContent');
            navigator.clipboard?.writeText(el.innerText).then(() => alert('ë³µì‚¬ë¨!'));
        }
    </script>
</body>
</html>
