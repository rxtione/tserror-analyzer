// i18n.js - Internationalization for TypeScript Error Analyzer
const i18n = {
    ko: {
        // Hero Section
        heroBadge: '무료 개발자 도구',
        heroTitle1: 'TypeScript 오류,',
        heroTitle2: '이제 쉽게 해결하세요',
        heroDesc: '"이 타입이 왜 안 맞지?" 더 이상 고민하지 마세요.<br>복잡한 타입 오류를 붙여넣기만 하면, 정확히 어떤 필드가 문제인지 콕 집어 알려드립니다.',
        heroFeature1: '정확한 오류 위치 추적',
        heroFeature2: '즉시 분석 결과',
        heroFeature3: '해결 방법 제안',
        heroStat1: '지원 오류 타입',
        heroStat2: '지원 언어',
        heroStat3: '무료',
        heroCta: '지금 바로 분석하기',
        expandHero: '소개 보기',

        // Main
        title: 'TypeScript 오류 분석기',
        subtitle: '복잡한 타입 오류를 분석하여 어떤 필드가 문제인지 명확하게 알려드립니다',
        inputTitle: '오류 메시지 입력',
        inputPlaceholder: 'TypeScript 오류 메시지를 여기에 붙여넣으세요...',
        analyzeBtn: '오류 분석',
        clearBtn: '초기화',
        sampleBtn: '예시 불러오기',
        resultTitle: '분석 결과',
        copyBtn: '복사',
        supportedTitle: '분석 가능한 오류',
        supported1: '배열/객체 타입 불일치',
        supported2: '속성 누락 오류',
        supported3: '중첩된 타입 오류',
        supported4: '유니온 타입 문제',
        supported5: '제네릭 타입 오류',
        supported6: '리터럴 타입 불일치',
        supported7: '모듈 찾기 오류',
        supported8: '변수/타입 미존재',
        howToTitle: '사용 방법',
        howTo1: 'TypeScript 오류를 복사',
        howTo2: '입력창에 붙여넣기',
        howTo3: '분석 버튼 클릭',
        howTo4: '문제점과 해결책 확인',
        aboutLink: '소개',
        privacyLink: '개인정보처리방침',
        termsLink: '이용약관',
        alertEmpty: '오류 메시지를 입력해주세요!',
        copied: '복사되었습니다!',
        noProblemsFound: '분석할 수 없는 오류입니다',
        feedbackDesc: '이 오류 패턴을 제보해 주시면 분석 기능을 개선하는 데 도움이 됩니다.',
        submitFeedback: '이 오류 제보하기',
        submitting: '제출 중...',
        feedbackSent: '감사합니다!',
        feedbackFailed: '제출에 실패했습니다. 잠시 후 다시 시도해주세요.',
        feedbackNotConfigured: '피드백 기능이 설정되지 않았습니다.',
        noErrorToReport: '제보할 오류가 없습니다.',
        foundProblems: '발견된 문제',
        arrayObjectMismatch: '객체(Object)를 배열(Array)이 필요한 곳에 전달했습니다!',
        missingProp: '누락된 속성',
        typeMismatch: '타입 불일치',
        arrayMismatch: '배열/객체 타입 불일치',
        genericError: '제네릭 타입 오류',
        unionError: '유니온 타입 오류',
        literalError: '리터럴 타입 불일치',
        literalErrorDesc: '정확한 리터럴 값이 일치하지 않습니다',
        literalStringSolution: '문자열 리터럴 타입은 정확한 값이 필요합니다',
        literalNumberSolution: '숫자 리터럴 타입은 정확한 값이 필요합니다',
        literalAsConstHint: 'as const를 사용하면 리터럴 타입으로 추론됩니다',
        literalWideningHint: '변수 선언 시 타입이 넓어질 수 있습니다 (예: "admin" → string)',
        moduleError: '모듈 찾기 실패',
        notFoundError: '존재하지 않는 이름',
        overloadError: '오버로드 매칭 실패',
        implicitAnyError: '암시적 any 타입',
        unknownTypeError: 'unknown 타입 오류',
        unknownTypeDesc: 'unknown 타입의 객체에는 직접 접근할 수 없습니다',
        possiblyUndefinedError: 'undefined일 수 있음',
        possiblyUndefinedDesc: '이 객체는 undefined일 수 있습니다',
        possiblyNullError: 'null일 수 있음',
        possiblyNullDesc: '이 객체는 null일 수 있습니다',
        possiblyNullOrUndefinedError: 'null 또는 undefined일 수 있음',
        possiblyNullOrUndefinedDesc: '이 객체는 null 또는 undefined일 수 있습니다',
        argumentCountError: '인자 개수 불일치',
        expectedArgs: '예상 인자 수',
        gotArgs: '전달된 인자 수',
        argumentCountSolution: '함수에 전달하는 인자 개수를 확인하세요',
        notCallableError: '호출 불가능',
        notCallableDesc: '이 표현식은 함수로 호출할 수 없습니다',
        notCallableSolution: '호출하려는 대상이 함수인지 확인하세요',
        notConstructableError: '생성자 아님',
        notConstructableDesc: '이 표현식은 생성자로 사용할 수 없습니다',
        notConstructableSolution: 'new 키워드와 함께 사용할 수 있는 클래스/생성자인지 확인하세요',
        mustReturnError: '반환값 필요',
        mustReturnDesc: 'void나 any가 아닌 반환 타입을 가진 함수는 값을 반환해야 합니다',
        operatorError: '연산자 오류',
        operatorErrorDesc: '연산자 "{op}"를 "{left}"와 "{right}" 타입에 적용할 수 없습니다',
        operatorSolution: '연산자를 적용할 수 있는 호환 가능한 타입으로 변환하세요',
        constraintError: '제약 조건 불충족',
        constraintErrorDesc: '타입 "{type}"이(가) 제약 조건 "{constraint}"를 만족하지 않습니다',
        constraintSolution: '제네릭 타입 매개변수의 제약 조건을 충족하는 타입을 사용하세요',
        conversionMistakeError: '타입 변환 실수',
        conversionMistakeDesc: '"{from}"에서 "{to}"로의 변환은 실수일 수 있습니다',
        useAsUnknown: 'unknown을 통한 변환 사용',
        basePropertyError: '기본 타입 속성 불일치',
        basePropertyDesc: '"{child}" 타입의 "{prop}" 속성이 기본 타입 "{base}"의 같은 속성과 호환되지 않습니다',
        basePropertySolution: '부모 타입의 속성 시그니처와 호환되도록 수정하세요',
        missingPropsFromDesc: '타입 "{source}"에 "{target}" 타입의 속성이 누락되었습니다',
        unintentionalComparisonError: '의도하지 않은 비교',
        unintentionalComparisonDesc: '이 비교/조건은 항상 "{result}"를 반환합니다',
        unintentionalComparisonSolution: '비교 대상의 타입을 확인하세요',
        usedBeforeAssignedError: '할당 전 사용',
        usedBeforeAssignedDesc: '변수 "{var}"이(가) 할당되기 전에 사용되었습니다',
        noInitializerError: '초기화되지 않음',
        noInitializerDesc: '속성 "{prop}"에 초기값이 없고 생성자에서 확실히 할당되지 않았습니다',
        undefinedNotAssignableError: 'undefined 할당 불가',
        nullNotAssignableError: 'null 할당 불가',
        nullishNotAssignableDesc: '"{nullish}"을(를) "{target}" 타입에 할당할 수 없습니다',
        genericArgsError: '제네릭 타입 인자 필요',
        genericArgsDesc: '제네릭 타입 "{type}"에는 {count}개의 타입 인자가 필요합니다',
        typeAsValueError: '타입을 값으로 사용',
        typeAsValueDesc: '"{name}"은(는) 타입이지만 값으로 사용되고 있습니다',
        valueAsTypeError: '값을 타입으로 사용',
        valueAsTypeDesc: '"{name}"은(는) 값이지만 타입으로 사용되고 있습니다',
        syntaxError: '구문 오류',
        syntaxExpectedDesc: '"{expected}"이(가) 예상됩니다',
        syntaxSolution: '코드에 "{expected}"을(를) 추가하세요',
        interfaceExtendError: '인터페이스 확장 오류',
        interfaceExtendDesc: '인터페이스 "{child}"이(가) "{parent}"를 올바르게 확장하지 않습니다',
        interfaceExtendSolution: '부모 인터페이스의 모든 필수 속성이 호환되는 타입으로 구현되었는지 확인하세요',
        classImplementError: '클래스 구현 오류',
        classImplementDesc: '클래스 "{class}"이(가) 인터페이스 "{interface}"를 올바르게 구현하지 않습니다',
        classImplementSolution: '인터페이스의 모든 필수 멤버를 클래스에 구현하세요',
        indexError: '인덱스 접근 오류',
        indexAccessDesc: '"{indexType}" 타입을 "{objectType}" 타입의 인덱스로 사용할 수 없습니다',
        invalidIndexDesc: '"{indexType}" 타입을 "{objectType}"의 인덱스로 사용할 수 없습니다',
        invalidIndexSolution: '올바른 인덱스 타입(string, number, symbol)을 사용하거나 인덱스 시그니처를 추가하세요',
        propertyNotExistSolution: '속성 이름을 확인하거나, 해당 타입에 속성을 추가하세요',
        providedType: '전달한 타입',
        expectedType: '기대하는 타입',
        solution: '해결 방법',
        wrapArray: '다음 속성들을 배열로 감싸주세요:',
        wrongCode: '// 잘못된 코드',
        correctCode: '// 올바른 코드',
        viewFullError: '전체 오류 메시지 보기',
        requiredProps: '필요한 속성',
        array: '배열',
        object: '객체',
        string: '문자열',
        number: '숫자',
        boolean: '불리언',
        installModule: '모듈을 설치하거나 경로를 확인하세요:',
        checkName: '변수/타입 이름을 확인하세요:',
        didYouMean: '혹시 이것을 의미하셨나요?'
    },
    en: {
        // Hero Section
        heroBadge: 'Free Developer Tool',
        heroTitle1: 'TypeScript Errors,',
        heroTitle2: 'Now Easy to Fix',
        heroDesc: '"Why doesn\'t this type match?" Stop wondering.<br>Just paste your complex type error, and we\'ll pinpoint exactly which field is the problem.',
        heroFeature1: 'Precise Error Location',
        heroFeature2: 'Instant Analysis',
        heroFeature3: 'Solution Suggestions',
        heroStat1: 'Error Types',
        heroStat2: 'Languages',
        heroStat3: 'Free',
        heroCta: 'Analyze Now',
        expandHero: 'Show Intro',

        // Main
        title: 'TypeScript Error Analyzer',
        subtitle: 'Analyze complex type errors and clearly identify which fields are problematic',
        inputTitle: 'Enter Error Message',
        inputPlaceholder: 'Paste your TypeScript error message here...',
        analyzeBtn: 'Analyze Error',
        clearBtn: 'Clear',
        sampleBtn: 'Load Sample',
        resultTitle: 'Analysis Result',
        copyBtn: 'Copy',
        supportedTitle: 'Supported Errors',
        supported1: 'Array/Object type mismatch',
        supported2: 'Missing property errors',
        supported3: 'Nested type errors',
        supported4: 'Union type problems',
        supported5: 'Generic type errors',
        supported6: 'Literal type mismatch',
        supported7: 'Module not found',
        supported8: 'Cannot find name',
        howToTitle: 'How to Use',
        howTo1: 'Copy TypeScript error',
        howTo2: 'Paste into input field',
        howTo3: 'Click analyze button',
        howTo4: 'Check problems and solutions',
        aboutLink: 'About',
        privacyLink: 'Privacy Policy',
        termsLink: 'Terms of Service',
        alertEmpty: 'Please enter an error message!',
        copied: 'Copied!',
        noProblemsFound: 'Unable to analyze this error',
        feedbackDesc: 'Report this error pattern to help us improve the analyzer.',
        submitFeedback: 'Report this error',
        submitting: 'Submitting...',
        feedbackSent: 'Thank you!',
        feedbackFailed: 'Submission failed. Please try again later.',
        feedbackNotConfigured: 'Feedback feature is not configured.',
        noErrorToReport: 'No error to report.',
        foundProblems: 'Problems Found',
        arrayObjectMismatch: 'You passed an Object where an Array was expected!',
        missingProp: 'Missing Property',
        typeMismatch: 'Type Mismatch',
        arrayMismatch: 'Array/Object Type Mismatch',
        genericError: 'Generic Type Error',
        unionError: 'Union Type Error',
        literalError: 'Literal Type Mismatch',
        literalErrorDesc: 'The exact literal value does not match',
        literalStringSolution: 'String literal types require the exact value',
        literalNumberSolution: 'Number literal types require the exact value',
        literalAsConstHint: 'Use "as const" to infer literal types',
        literalWideningHint: 'Variable declarations may widen the type (e.g., "admin" → string)',
        moduleError: 'Module Not Found',
        notFoundError: 'Cannot Find Name',
        overloadError: 'No Overload Matches',
        implicitAnyError: 'Implicit Any Type',
        unknownTypeError: 'Unknown Type Error',
        unknownTypeDesc: 'Cannot directly access properties on an unknown type object',
        possiblyUndefinedError: 'Possibly Undefined',
        possiblyUndefinedDesc: 'This object might be undefined',
        possiblyNullError: 'Possibly Null',
        possiblyNullDesc: 'This object might be null',
        possiblyNullOrUndefinedError: 'Possibly Null or Undefined',
        possiblyNullOrUndefinedDesc: 'This object might be null or undefined',
        argumentCountError: 'Argument Count Mismatch',
        expectedArgs: 'Expected arguments',
        gotArgs: 'Got',
        argumentCountSolution: 'Check the number of arguments passed to the function',
        notCallableError: 'Not Callable',
        notCallableDesc: 'This expression cannot be called as a function',
        notCallableSolution: 'Verify that the target is actually a function',
        notConstructableError: 'Not Constructable',
        notConstructableDesc: 'This expression cannot be used as a constructor',
        notConstructableSolution: 'Verify that you are using a class or constructor function with new',
        mustReturnError: 'Must Return Value',
        mustReturnDesc: 'A function with a non-void/any return type must return a value',
        operatorError: 'Operator Error',
        operatorErrorDesc: 'Operator "{op}" cannot be applied to types "{left}" and "{right}"',
        operatorSolution: 'Convert to compatible types that support this operator',
        constraintError: 'Constraint Not Satisfied',
        constraintErrorDesc: 'Type "{type}" does not satisfy the constraint "{constraint}"',
        constraintSolution: 'Use a type that satisfies the generic type parameter constraint',
        conversionMistakeError: 'Conversion Mistake',
        conversionMistakeDesc: 'Conversion from "{from}" to "{to}" may be a mistake',
        useAsUnknown: 'Use conversion through unknown',
        basePropertyError: 'Base Property Mismatch',
        basePropertyDesc: 'Property "{prop}" in type "{child}" is not assignable to the same property in base type "{base}"',
        basePropertySolution: 'Modify to be compatible with the parent type property signature',
        missingPropsFromDesc: 'Type "{source}" is missing properties from type "{target}"',
        unintentionalComparisonError: 'Unintentional Comparison',
        unintentionalComparisonDesc: 'This comparison/condition will always return "{result}"',
        unintentionalComparisonSolution: 'Check the types being compared',
        usedBeforeAssignedError: 'Used Before Assigned',
        usedBeforeAssignedDesc: 'Variable "{var}" is used before being assigned',
        noInitializerError: 'No Initializer',
        noInitializerDesc: 'Property "{prop}" has no initializer and is not definitely assigned in constructor',
        undefinedNotAssignableError: 'Undefined Not Assignable',
        nullNotAssignableError: 'Null Not Assignable',
        nullishNotAssignableDesc: 'Cannot assign "{nullish}" to type "{target}"',
        genericArgsError: 'Generic Arguments Required',
        genericArgsDesc: 'Generic type "{type}" requires {count} type argument(s)',
        typeAsValueError: 'Type Used as Value',
        typeAsValueDesc: '"{name}" refers to a type but is being used as a value',
        valueAsTypeError: 'Value Used as Type',
        valueAsTypeDesc: '"{name}" refers to a value but is being used as a type',
        syntaxError: 'Syntax Error',
        syntaxExpectedDesc: '"{expected}" expected',
        syntaxSolution: 'Add "{expected}" to your code',
        interfaceExtendError: 'Interface Extend Error',
        interfaceExtendDesc: 'Interface "{child}" incorrectly extends interface "{parent}"',
        interfaceExtendSolution: 'Ensure all required properties from the parent interface are implemented with compatible types',
        classImplementError: 'Class Implement Error',
        classImplementDesc: 'Class "{class}" incorrectly implements interface "{interface}"',
        classImplementSolution: 'Implement all required members from the interface in your class',
        indexError: 'Index Access Error',
        indexAccessDesc: 'Type "{indexType}" cannot be used to index type "{objectType}"',
        invalidIndexDesc: 'Type "{indexType}" cannot be used as an index for "{objectType}"',
        invalidIndexSolution: 'Use a valid index type (string, number, symbol) or add an index signature',
        propertyNotExistSolution: 'Check the property name or add the property to the type',
        providedType: 'Provided Type',
        expectedType: 'Expected Type',
        solution: 'Solution',
        wrapArray: 'Wrap the following properties in an array:',
        wrongCode: '// Wrong code',
        correctCode: '// Correct code',
        viewFullError: 'View Full Error Message',
        requiredProps: 'Required properties',
        array: 'Array',
        object: 'Object',
        string: 'String',
        number: 'Number',
        boolean: 'Boolean',
        installModule: 'Install the module or check the path:',
        checkName: 'Check the variable/type name:',
        didYouMean: 'Did you mean?'
    },
    ja: {
        // Hero Section
        heroBadge: '無料開発者ツール',
        heroTitle1: 'TypeScriptエラー、',
        heroTitle2: 'もう簡単に解決',
        heroDesc: '「なぜこの型が合わないの？」もう悩まないで。<br>複雑な型エラーを貼り付けるだけで、どのフィールドに問題があるか正確に教えます。',
        heroFeature1: '正確なエラー位置追跡',
        heroFeature2: '即座に分析結果',
        heroFeature3: '解決方法を提案',
        heroStat1: '対応エラータイプ',
        heroStat2: '対応言語',
        heroStat3: '無料',
        heroCta: '今すぐ分析する',
        expandHero: '紹介を見る',

        // Main
        title: 'TypeScript エラー分析ツール',
        subtitle: '複雑な型エラーを分析し、どのフィールドに問題があるかを明確に示します',
        inputTitle: 'エラーメッセージを入力',
        inputPlaceholder: 'TypeScriptエラーメッセージをここに貼り付けてください...',
        analyzeBtn: 'エラー分析',
        clearBtn: 'クリア',
        sampleBtn: 'サンプルを読み込む',
        resultTitle: '分析結果',
        copyBtn: 'コピー',
        supportedTitle: '対応エラー',
        supported1: '配列/オブジェクト型の不一致',
        supported2: 'プロパティの欠落エラー',
        supported3: 'ネストされた型エラー',
        supported4: 'ユニオン型の問題',
        supported5: 'ジェネリック型エラー',
        supported6: 'リテラル型の不一致',
        supported7: 'モジュールが見つからない',
        supported8: '名前が見つからない',
        howToTitle: '使い方',
        howTo1: 'TypeScriptエラーをコピー',
        howTo2: '入力欄に貼り付け',
        howTo3: '分析ボタンをクリック',
        howTo4: '問題点と解決策を確認',
        aboutLink: '紹介',
        privacyLink: 'プライバシーポリシー',
        termsLink: '利用規約',
        alertEmpty: 'エラーメッセージを入力してください！',
        copied: 'コピーしました！',
        noProblemsFound: 'このエラーを分析できません',
        feedbackDesc: 'このエラーパターンを報告していただくと、分析機能の改善に役立ちます。',
        submitFeedback: 'このエラーを報告',
        submitting: '送信中...',
        feedbackSent: 'ありがとうございます！',
        feedbackFailed: '送信に失敗しました。後でもう一度お試しください。',
        feedbackNotConfigured: 'フィードバック機能が設定されていません。',
        noErrorToReport: '報告するエラーがありません。',
        foundProblems: '発見された問題',
        arrayObjectMismatch: '配列が必要な場所にオブジェクトを渡しました！',
        missingProp: '欠落プロパティ',
        typeMismatch: '型の不一致',
        arrayMismatch: '配列/オブジェクト型の不一致',
        genericError: 'ジェネリック型エラー',
        unionError: 'ユニオン型エラー',
        literalError: 'リテラル型の不一致',
        literalErrorDesc: '正確なリテラル値が一致しません',
        literalStringSolution: '文字列リテラル型には正確な値が必要です',
        literalNumberSolution: '数値リテラル型には正確な値が必要です',
        literalAsConstHint: 'as constを使用するとリテラル型として推論されます',
        literalWideningHint: '変数宣言時に型が広がる可能性があります（例："admin" → string）',
        moduleError: 'モジュールが見つからない',
        notFoundError: '名前が見つからない',
        overloadError: 'オーバーロードが一致しない',
        implicitAnyError: '暗黙的なany型',
        unknownTypeError: 'unknown型エラー',
        unknownTypeDesc: 'unknown型のオブジェクトに直接アクセスできません',
        possiblyUndefinedError: 'undefinedの可能性',
        possiblyUndefinedDesc: 'このオブジェクトはundefinedである可能性があります',
        possiblyNullError: 'nullの可能性',
        possiblyNullDesc: 'このオブジェクトはnullである可能性があります',
        possiblyNullOrUndefinedError: 'nullまたはundefinedの可能性',
        possiblyNullOrUndefinedDesc: 'このオブジェクトはnullまたはundefinedである可能性があります',
        argumentCountError: '引数の数が不一致',
        expectedArgs: '期待される引数',
        gotArgs: '渡された引数',
        argumentCountSolution: '関数に渡す引数の数を確認してください',
        notCallableError: '呼び出し不可',
        notCallableDesc: 'この式は関数として呼び出せません',
        notCallableSolution: '呼び出し対象が関数かどうか確認してください',
        notConstructableError: 'コンストラクタではない',
        notConstructableDesc: 'この式はコンストラクタとして使用できません',
        notConstructableSolution: 'newキーワードと一緒に使用できるクラス/コンストラクタか確認してください',
        mustReturnError: '戻り値が必要',
        mustReturnDesc: 'void/any以外の戻り値型を持つ関数は値を返す必要があります',
        operatorError: '演算子エラー',
        operatorErrorDesc: '演算子"{op}"を"{left}"と"{right}"型に適用できません',
        operatorSolution: 'この演算子をサポートする互換性のある型に変換してください',
        constraintError: '制約条件を満たさない',
        constraintErrorDesc: '型"{type}"は制約"{constraint}"を満たしていません',
        constraintSolution: 'ジェネリック型パラメータの制約を満たす型を使用してください',
        conversionMistakeError: '型変換の間違い',
        conversionMistakeDesc: '"{from}"から"{to}"への変換は間違いの可能性があります',
        useAsUnknown: 'unknownを介した変換を使用',
        basePropertyError: '基本型プロパティの不一致',
        basePropertyDesc: '"{child}"型の"{prop}"プロパティは基本型"{base}"の同じプロパティと互換性がありません',
        basePropertySolution: '親型のプロパティシグネチャと互換性があるように修正してください',
        missingPropsFromDesc: '型"{source}"には"{target}"型のプロパティが欠落しています',
        unintentionalComparisonError: '意図しない比較',
        unintentionalComparisonDesc: 'この比較/条件は常に"{result}"を返します',
        unintentionalComparisonSolution: '比較される型を確認してください',
        usedBeforeAssignedError: '代入前に使用',
        usedBeforeAssignedDesc: '変数"{var}"が代入される前に使用されています',
        noInitializerError: '初期化されていない',
        noInitializerDesc: 'プロパティ"{prop}"に初期値がなく、コンストラクタで確実に代入されていません',
        undefinedNotAssignableError: 'undefinedを代入不可',
        nullNotAssignableError: 'nullを代入不可',
        nullishNotAssignableDesc: '"{nullish}"を型"{target}"に代入できません',
        genericArgsError: 'ジェネリック引数が必要',
        genericArgsDesc: 'ジェネリック型"{type}"には{count}個の型引数が必要です',
        typeAsValueError: '型を値として使用',
        typeAsValueDesc: '"{name}"は型ですが、値として使用されています',
        valueAsTypeError: '値を型として使用',
        valueAsTypeDesc: '"{name}"は値ですが、型として使用されています',
        syntaxError: '構文エラー',
        syntaxExpectedDesc: '"{expected}"が必要です',
        syntaxSolution: 'コードに"{expected}"を追加してください',
        interfaceExtendError: 'インターフェース拡張エラー',
        interfaceExtendDesc: 'インターフェース"{child}"が"{parent}"を正しく拡張していません',
        interfaceExtendSolution: '親インターフェースのすべての必須プロパティが互換性のある型で実装されていることを確認してください',
        classImplementError: 'クラス実装エラー',
        classImplementDesc: 'クラス"{class}"がインターフェース"{interface}"を正しく実装していません',
        classImplementSolution: 'インターフェースのすべての必須メンバーをクラスに実装してください',
        indexError: 'インデックスアクセスエラー',
        indexAccessDesc: '型"{indexType}"を型"{objectType}"のインデックスとして使用できません',
        invalidIndexDesc: '型"{indexType}"を"{objectType}"のインデックスとして使用できません',
        invalidIndexSolution: '有効なインデックス型（string、number、symbol）を使用するか、インデックスシグネチャを追加してください',
        propertyNotExistSolution: 'プロパティ名を確認するか、型にプロパティを追加してください',
        providedType: '渡された型',
        expectedType: '期待される型',
        solution: '解決方法',
        wrapArray: '次のプロパティを配列でラップしてください：',
        wrongCode: '// 間違ったコード',
        correctCode: '// 正しいコード',
        viewFullError: '完全なエラーメッセージを表示',
        requiredProps: '必要なプロパティ',
        array: '配列',
        object: 'オブジェクト',
        string: '文字列',
        number: '数値',
        boolean: 'ブール',
        installModule: 'モジュールをインストールするか、パスを確認してください：',
        checkName: '変数/型の名前を確認してください：',
        didYouMean: 'もしかして？'
    },
    zh: {
        // Hero Section
        heroBadge: '免费开发者工具',
        heroTitle1: 'TypeScript 错误，',
        heroTitle2: '现在轻松解决',
        heroDesc: '"为什么这个类型不匹配？"别再纠结了。<br>只需粘贴复杂的类型错误，我们会准确告诉你哪个字段有问题。',
        heroFeature1: '精准错误定位',
        heroFeature2: '即时分析结果',
        heroFeature3: '解决方案建议',
        heroStat1: '支持错误类型',
        heroStat2: '支持语言',
        heroStat3: '免费',
        heroCta: '立即分析',
        expandHero: '查看介绍',

        // Main
        title: 'TypeScript 错误分析器',
        subtitle: '分析复杂的类型错误，清楚地识别哪些字段有问题',
        inputTitle: '输入错误消息',
        inputPlaceholder: '在此粘贴 TypeScript 错误消息...',
        analyzeBtn: '分析错误',
        clearBtn: '清除',
        sampleBtn: '加载示例',
        resultTitle: '分析结果',
        copyBtn: '复制',
        supportedTitle: '支持的错误',
        supported1: '数组/对象类型不匹配',
        supported2: '缺少属性错误',
        supported3: '嵌套类型错误',
        supported4: '联合类型问题',
        supported5: '泛型类型错误',
        supported6: '字面量类型不匹配',
        supported7: '找不到模块',
        supported8: '找不到名称',
        howToTitle: '使用方法',
        howTo1: '复制 TypeScript 错误',
        howTo2: '粘贴到输入框',
        howTo3: '点击分析按钮',
        howTo4: '查看问题和解决方案',
        aboutLink: '关于',
        privacyLink: '隐私政策',
        termsLink: '服务条款',
        alertEmpty: '请输入错误消息！',
        copied: '已复制！',
        noProblemsFound: '无法分析此错误',
        feedbackDesc: '报告此错误模式可以帮助我们改进分析器。',
        submitFeedback: '报告此错误',
        submitting: '提交中...',
        feedbackSent: '谢谢！',
        feedbackFailed: '提交失败，请稍后再试。',
        feedbackNotConfigured: '反馈功能未配置。',
        noErrorToReport: '没有要报告的错误。',
        foundProblems: '发现的问题',
        arrayObjectMismatch: '您在需要数组的地方传递了对象！',
        missingProp: '缺少属性',
        typeMismatch: '类型不匹配',
        arrayMismatch: '数组/对象类型不匹配',
        genericError: '泛型类型错误',
        unionError: '联合类型错误',
        literalError: '字面量类型不匹配',
        literalErrorDesc: '精确的字面量值不匹配',
        literalStringSolution: '字符串字面量类型需要精确的值',
        literalNumberSolution: '数字字面量类型需要精确的值',
        literalAsConstHint: '使用 "as const" 可以推断为字面量类型',
        literalWideningHint: '变量声明时类型可能会被扩展（例如："admin" → string）',
        moduleError: '找不到模块',
        notFoundError: '找不到名称',
        overloadError: '没有匹配的重载',
        implicitAnyError: '隐式 any 类型',
        unknownTypeError: 'unknown 类型错误',
        unknownTypeDesc: '无法直接访问 unknown 类型对象的属性',
        possiblyUndefinedError: '可能为 undefined',
        possiblyUndefinedDesc: '此对象可能为 undefined',
        possiblyNullError: '可能为 null',
        possiblyNullDesc: '此对象可能为 null',
        possiblyNullOrUndefinedError: '可能为 null 或 undefined',
        possiblyNullOrUndefinedDesc: '此对象可能为 null 或 undefined',
        argumentCountError: '参数数量不匹配',
        expectedArgs: '期望参数',
        gotArgs: '实际参数',
        argumentCountSolution: '检查传递给函数的参数数量',
        notCallableError: '不可调用',
        notCallableDesc: '此表达式不能作为函数调用',
        notCallableSolution: '验证目标是否确实是一个函数',
        notConstructableError: '不可构造',
        notConstructableDesc: '此表达式不能用作构造函数',
        notConstructableSolution: '验证是否正在使用带有 new 的类或构造函数',
        mustReturnError: '必须返回值',
        mustReturnDesc: '具有非 void/any 返回类型的函数必须返回一个值',
        operatorError: '运算符错误',
        operatorErrorDesc: '运算符 "{op}" 不能应用于类型 "{left}" 和 "{right}"',
        operatorSolution: '转换为支持此运算符的兼容类型',
        constraintError: '不满足约束',
        constraintErrorDesc: '类型 "{type}" 不满足约束 "{constraint}"',
        constraintSolution: '使用满足泛型类型参数约束的类型',
        conversionMistakeError: '类型转换错误',
        conversionMistakeDesc: '从 "{from}" 到 "{to}" 的转换可能是错误的',
        useAsUnknown: '通过 unknown 进行转换',
        basePropertyError: '基类属性不匹配',
        basePropertyDesc: '类型 "{child}" 中的属性 "{prop}" 无法分配给基类型 "{base}" 中的相同属性',
        basePropertySolution: '修改为与父类型属性签名兼容',
        missingPropsFromDesc: '类型 "{source}" 缺少来自类型 "{target}" 的属性',
        unintentionalComparisonError: '无意的比较',
        unintentionalComparisonDesc: '此比较/条件将始终返回 "{result}"',
        unintentionalComparisonSolution: '检查正在比较的类型',
        usedBeforeAssignedError: '赋值前使用',
        usedBeforeAssignedDesc: '变量 "{var}" 在赋值之前被使用',
        noInitializerError: '未初始化',
        noInitializerDesc: '属性 "{prop}" 没有初始值，且未在构造函数中明确赋值',
        undefinedNotAssignableError: '不能分配 undefined',
        nullNotAssignableError: '不能分配 null',
        nullishNotAssignableDesc: '不能将 "{nullish}" 分配给类型 "{target}"',
        genericArgsError: '需要泛型参数',
        genericArgsDesc: '泛型类型 "{type}" 需要 {count} 个类型参数',
        typeAsValueError: '类型用作值',
        typeAsValueDesc: '"{name}" 是类型，但被用作值',
        valueAsTypeError: '值用作类型',
        valueAsTypeDesc: '"{name}" 是值，但被用作类型',
        syntaxError: '语法错误',
        syntaxExpectedDesc: '需要 "{expected}"',
        syntaxSolution: '在代码中添加 "{expected}"',
        interfaceExtendError: '接口扩展错误',
        interfaceExtendDesc: '接口 "{child}" 未正确扩展接口 "{parent}"',
        interfaceExtendSolution: '确保父接口的所有必需属性都以兼容的类型实现',
        classImplementError: '类实现错误',
        classImplementDesc: '类 "{class}" 未正确实现接口 "{interface}"',
        classImplementSolution: '在类中实现接口的所有必需成员',
        indexError: '索引访问错误',
        indexAccessDesc: '类型 "{indexType}" 不能用于索引类型 "{objectType}"',
        invalidIndexDesc: '类型 "{indexType}" 不能用作 "{objectType}" 的索引',
        invalidIndexSolution: '使用有效的索引类型（string、number、symbol）或添加索引签名',
        propertyNotExistSolution: '检查属性名称或将属性添加到类型',
        providedType: '提供的类型',
        expectedType: '期望的类型',
        solution: '解决方案',
        wrapArray: '请将以下属性包装在数组中：',
        wrongCode: '// 错误代码',
        correctCode: '// 正确代码',
        viewFullError: '查看完整错误消息',
        requiredProps: '必需的属性',
        array: '数组',
        object: '对象',
        string: '字符串',
        number: '数字',
        boolean: '布尔',
        installModule: '安装模块或检查路径：',
        checkName: '检查变量/类型名称：',
        didYouMean: '您是否是指？'
    }
};

let currentLang = localStorage.getItem('lang') ||
    (navigator.language.startsWith('ko') ? 'ko' :
     navigator.language.startsWith('ja') ? 'ja' :
     navigator.language.startsWith('zh') ? 'zh' : 'en');

// Keys that contain HTML and should use innerHTML
const htmlKeys = ['heroDesc'];

function setLanguage(lang) {
    currentLang = lang;
    localStorage.setItem('lang', lang);
    document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.lang === lang);
    });
    document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.dataset.i18n;
        if (i18n[lang][key]) {
            if (htmlKeys.includes(key)) {
                el.innerHTML = i18n[lang][key];
            } else {
                el.textContent = i18n[lang][key];
            }
        }
    });
    document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        const key = el.dataset.i18nPlaceholder;
        if (i18n[lang][key]) {
            el.placeholder = i18n[lang][key];
        }
    });
    document.documentElement.lang = lang === 'zh' ? 'zh-CN' : lang;
}

function t(key) {
    return i18n[currentLang][key] || i18n['en'][key] || key;
}

// Initialize language from URL parameter
const urlParams = new URLSearchParams(window.location.search);
const langParam = urlParams.get('lang');
if (langParam && i18n[langParam]) {
    currentLang = langParam;
}
